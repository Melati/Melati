<HTML>
<HEAD>
<TITLE> org.melati Functional Specification (document $Revision$) </TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso8859-1">
</HEAD>
<BODY BGCOLOR=#FFFFFF>

<H1><TT>org.melati</TT> Functional Specification
    (document $Revision$)</H1>

<P>
  This document provides a specification of the ways in which the system
  interacts with users.	 See also the system's <A HREF=QA.html>master QA
  document</A>.
</P>




<H2>
<!-- ************************************************ -->
      Paneris programmers; the open-source community
<!-- ************************************************ -->
</H2>

<P>
  For an incomplete sketch of part of the API, look at the <A
  HREF=javadoc/packages.html><TT>javadoc</TT></A> documentation.
</P>



<H3><A NAME=data-def>
<!-- =========================== -->
      Data structure definition
<!-- =========================== -->
</A></H3>

<P>
  The data structure definition is a single file which describes, in a form
  similar to a series of Java class declarations, the tables and fields which
  the program definitely expects to find in the database.  If a field
  <TT>foo</TT> is declared in this file, it may be used in a type-safe way by
  the Java code, via automatically generated <TT>getFoo</TT>/<TT>setFoo</TT>
  method pairs; furthermore, the programmer has the opportunity to override
  those methods or add further operations in order to express the `business
  logic' of the `persistent classes' in a convenient and familiar way.
</P>

<P>
  However, the data structure definition is not exclusive: other tables and
  fields may be present in the underlying RDBMS database, and they will be
  available for generic processing in dynamically generated reports and forms.
  These undefined fields can also be referred to by their literal names, albeit
  in a non-type-safe way, by the programmer if she does not wish to go to the
  trouble of putting them in the data structure definition.
</P>


<H4>
<!-- ---------- -->
      Dataflow
<!-- ---------- -->
</H4>

<P>
  The data structure definition is processed into a set of machine-generated
  Java files, including a Java schema representation whose job is to initialise
  (and subsequently check the consistency of) the running database when the
  Melati application is started up.
</P>



<H4><A NAME=dsd-example>
<!-- ------------------- -->
      Annotated example
<!-- ------------------- -->
</A></H4>

<P>
  The following snippet shows part of the data structure definition for an
  invoicing system.  It is followed by a key explaining what the various
  constructs mean.
</P>

<BLOCKQUOTE><PRE>
table Invoice {
  (primary) int id;
  Date taxDate;
  (indexed) Party issuer;	     // a reference
  (unique with issuer) String number (maxlength = 10);
  (indexed) Party receiver;
  InvoiceLine.invoice Subset lines;  // an owned list
  Textarea notes (width = 50, height = 5);
}

table InvoiceLine {
  (primary) int id;
  Product product (combo);
  (indexed) Invoice.id invoice;
}

(maxcached = 1000) table Party {
  (primary) int id;
  (unique) String name;
}
</PRE></BLOCKQUOTE>

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
  <TR VALIGN=TOP>
    <TD><TT>table</TT></TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      Each <TT>table</TT> declaration corresponds to one table in the
      underlying database and one Java class.  The system can autogenerate both
      a base definition for the class, including transparent marshalling, and,
      optionally, the database table (using SQL <TT>CREATE</TT> <TT>TABLE</TT>
      and <TT>CREATE</TT> <TT>INDEX</TT> commands).
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD>field definitions</TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      A table's fields are basically declared in the familiar
      <TT><I>type</I></TT> <TT><I>name</I>;</TT> format.  For instance, the
      <TT>date</TT> declaration in <TT>Invoice</TT> will give rise to a field
      called <TT>date</TT> in the <TT>Invoice</TT> database table and a pair of
      methods

      <BLOCKQUOTE><TT>
	Date getDate();<BR>
	void setDate(Date date);
      </TT></BLOCKQUOTE>

      in the <TT>Invoice</TT> class.  `Attributes' specifying the indices
      required for each field and default display preferences are given in
      parentheses.
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD><TT>(indexed)</TT></TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      If a table is specified as being indexed by a particular field, the index
      will be generated automatically when the data structure definition is
      processed.  <FONT COLOR=red>FIXME: Possibly some more sophisticated
      mechanism for passing SQL index-type parameters will be needed?</FONT>
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD><TT>(unique)</TT></TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      It's also possible to specify that every record in the table must have a
      different value for a particular field.  <TT>unique</TT> implies
      <TT>indexed</TT>.
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD><TT>(</TT>...<TT> with <I>field</I>)</TT></TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      Fields can be indexed or made unique jointly with each other.  <FONT
      COLOR=red>FIXME: This feature is perhaps not a priority but would seem to
      be required for some purposes.</FONT>
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD><TT>(primary)</TT></TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD><A NAME=primary>

      One field in each table must be designated as a primary key.  The system
      uses this as an OID (object identifier) to help it manage the cache.  The
      <TT>primary</TT> field need not necessarily be called <TT>id</TT>.  By
      implication, it is indexed and unique, and the system takes care of
      setting and reading its value: the programmer will hardly ever have to
      use it explicitly.
    </A></TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD>references</TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      References (links) between objects---in RDB jargon, `one-to-one'
      relationships between records---are specified just like string or numeric
      fields, in the form

      <BLOCKQUOTE><TT>
	<I>target-table</I> <I>name</I>;
      </TT></BLOCKQUOTE>

      The target field of a reference is always the target table's primary key.
      For instance, the <TT>issuer</TT> declaration in <TT>Invoice</TT> will
      give rise to a field <TT>issuer</TT> in the <TT>Invoice</TT> table which
      contains the primary <TT>id</TT> number of a <TT>Party</TT> record, and
      to a pair of methods

      <BLOCKQUOTE><TT>
	Party getIssuer()<BR>
	void setIssuer(Party isser);
      </TT></BLOCKQUOTE>

      in the <TT>Invoice</TT> class which deal directly in objects representing
      the linked <TT>Party</TT>: the necessary dereferencing happens
      transparently.
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD>owned lists</TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      Owned lists of objects, similar to Java <TT>Vector</TT>s and expressed in
      RDBs as `one-to-many' relationships between records, are specified in the
      form

      <BLOCKQUOTE><TT>
	<I>target-table</I>.<I>link-field</I> Subset <I>name</I>;
      </TT></BLOCKQUOTE>

      For instance, the <TT>lines</TT> declaration in <TT>Invoice</TT> will
      cause the system to check that <TT>InvoiceLine</TT> has an indexed field
      <TT>invoice</TT>, and give rise to a method

      <BLOCKQUOTE><TT>
	Subset getLines();
      </TT></BLOCKQUOTE>

      in the <TT>Invoice</TT> class, which returns an object behaving somewhat
      like a <TT>Vector</TT> (FIXME say more ...).
    </TD>
  </TR>

  <TR><TD><FONT SIZE=0>&nbsp;</FONT></TD></TR>

  <TR VALIGN=TOP>
    <TD><TT>(maxcached = </TT>...<TT>)</TT></TD>
    <TD>&nbsp;&nbsp;</TD>
    <TD>
      A limit can be placed on the number of records from each table which will
      be held in the <A HREF=#cacheing>cache</A>.  If omitted, it defaults to
      some suitably small number.
    </TD>
  </TR>
</TABLE>


<H4>
<!-- ------------------------- -->
      Unboxed compound fields
<!-- ------------------------- -->
</H4>

<P>
  Sometimes, it would be convenient to be able to embed sub-records inside a
  table row, rather than linking into a separate table.	 For instance, we might
  want to express a quantity of money in an arbitrary currency, by including a
  reference to the currency in question along with the numeric amount;
  logically, the two fields form a single unit of data, and could well be
  grouped into an object.  At this stage, though, it's not clear that features
  for dealing cleanly with this situation would be sufficiently beneficial to
  offset the work required to implement them; furthermore, they would
  inevitably obfuscate the API to some extent, making it less Java-like,
  because in Java's memory model all compound structures are stored as
  independent `boxed' entities.
</P>


<H4>
<!-- ------------- -->
      Inheritance
<!-- ------------- -->
</H4>

<P>
  For some purposes, it might be nice to support inheritance between tables (as
  Postgres does).  Getting the corresponding Java classes arranged in a
  hierarchy which mirrored that defined on the tables could probably be
  managed, albeit slightly untidily given the lack of multiple inheritance.
  This feature is not considered to be a priority for the moment.
</P>


<H4>
<!-- ----------------- -->
      Delivery medium
<!-- ----------------- -->
</H4>

<P>
  Programmers write the data structure definition using their favourite text
  editor, just like the write Java code.  They must then run a processor over
  the file in order to generate the Java base class definitions for the
  persistent classes and the database validation/initialisation code.  The
  processor is written in Java so that any programmer wishing to use Melati
  will be able to compile and run it straightforwardly.  Programmers who use
  <TT>make</TT>-like utilities can arrange for the processor to be run
  automatically when the data structure definition file is changed; however, it
  is not anticipated that this will happen very often, so manual intervention
  will not be a major chore.
</P>



<H3><A NAME=access>
<!-- ================ -->
      Access control
<!-- ================ -->
</A></H3>


<H4>
<!-- ------------------------ -->
      The capabilities model
<!-- ------------------------ -->
</H4>

<P>
  Deciding how permissions are expressed in the API means making tradeoffs
  between flexibility, administrative convenience and implementational
  efficiency.  At the moment, JAL supports arbitrary access control lists for
  records, templates and controllers, expressed in terms of user groups;
  exceptions to the default policy (world-readable and world-writeable) are
  stored in the <TT>userpermissions</TT> table, and queried by means of a
  three-table join along with <TT>userresourcetypes</TT> and
  <TT>userresourcetypes</TT>.  Although this API is very flexible, it
  undoubtedly adds some overhead which we might, on the general principle that
  scalability can only be achieved by constant discipline, seek to avoid even
  though it's clear that it's not a problem right now.	(Since the size of the
  ACL table may well scale linearly with that of the overall data set, it is
  probably not sensible to attempt to cache it.)  Furthermore, in order to
  implement any given access policy, it's necessary for an administrator or
  administrative process to set up an appropriate ACL.
</P>

<P>
  For Melati, it is proposed that we move to the following model:
</P>

<UL>
  <LI> Every class representing a database table supports a pair of methods

       <BLOCKQUOTE><TT>
	  void assertReadable(AccessToken token) throws AccessException;<BR>
	  void assertWriteable(AccessToken token) throws AccessException;
       </TT></BLOCKQUOTE>

       which throw some informative exception if <TT>token</TT> is not
       sufficient to permit reading/writing the record's fields.

  <LI> The system invokes the appropriate access-assertion method whenever a
       field of a persistent object is read or written to (via its
       <TT>setFoo</TT>/<TT>getFoo</TT> methods).  This is how low-level checks
       are automatically enforced.

  <LI> If the fields

       <BLOCKQUOTE><TT>
	  Capability readCapability;<BR>
	  Capability writeCapability;
       </TT></BLOCKQUOTE>

       are defined for a table and are non-null in the record under
       consideration, the default (base-class) access-assertion methods check
       <TT>token</TT> against them explicitly.	It's possible to define
       arbitrary permissions for an object, but only in terms of a single
       capability which is stored in the same table row as the record's actual
       data fields.  An example of a capability might be `writeable by a
       trusted participant of the FooWeb project'.  This scheme is similar to
       the supplementary group mechanism of the Unix filesystem, and (in fact)
       to Turbine's user/role/permission system.

  <LI> The programmer can override the access-assertion methods for a
       persistent class if she wants to implement a consistent policy (provided
       that the class is defined in the <A HREF=#data-def>data structure
       definition</A>).	 For instance, the following fragment <A
       HREF=javadoc/org.melati.doc.example.Invoice.html>from the example
       database</A> would make invoices (though not their lines) readable by
       their issuer as well as by anyone with an explicit
       <TT>readCapability</TT>:

       <BLOCKQUOTE><PRE>
public class Invoice extends InvoiceBase {
  public void assertReadable(AccessToken token) throws AccessException {
    if (token.getUser() != getIssuer() && token.getUser() != getReceiver())
      super.assertReadable(token);
  }
}
       </PRE></BLOCKQUOTE>

  <A NAME=cap-group><LI> Users are assigned to groups, possibly depending on how
       `far' they have chosen to log themselves in, and capabilities can be
       assigned to groups or to groups of groups, <I>etc</I>.  In a
       well-designed setup, the group-capability information is compact enough
       to be cached in its entirety.</A>
</UL>

<P>
  We are not interested in supporting generic field-specific access control,
  but special rules can be supported programmatically by overriding a class's
  setter/getter methods.  For example, the following fragment would prevent
  changes to an invoice's <TT>taxDate</TT> after the invoice had been
  `finalised' (as determined by a method <TT>isFinalised</TT> which is here
  left undefined); the date could still be force-changed using a separate
  method, but a special capability would be required.
</P>

<BLOCKQUOTE><PRE>
public class Invoice extends InvoiceBase {
  public void setTaxDate(Date date) {
    if (isFinalised())
      throw new BlahException("rhubarb");
    else
      super.setTaxDate(date);
  }

  public void setTaxDate_force(Date date) {
    if (!Implicit.accessToken().hasCapability(forceInvoiceDetails))
      throw new BlahException("rhubarb");
    else
      super.setTaxDate(date);
  }
}
</PRE></BLOCKQUOTE>


<H4>
<!-- ----------------------- -->
      Early or late checks?
<!-- ----------------------- -->
</H4>

<P>
  Another issue which has to be resolved is the question of when the low-level
  access control checks are performed.	Two different models were considered:
</P>

<UL>
  <LI> <I>Partly static.</I> At the beginning of a task
       involving an object, the programmer asks for a handle providing the
       level of access she needs.  The handle <I>is</I> the object as far as
       she is concerned (except for <TT>==</TT> tests), but it doesn't offer
       any methods from the higher access levels.  Once she has the handle, she
       can be sure at compile time that no accesses of its fields will fail for
       want of permission.

  <LI> <I><A NAME=access-dynamic>Dynamic.</A></I> All object handles
       support all possible methods, but they may throw an `access denied'
       exception if the user on behalf of whom the operation is being carried
       out does not have the appropriate clearance.
</UL>

<P>
  The partly static method has the advantage that it uses the type system, to
  some extent, to help the programmer identify early on what level of access
  she needs to an object, and documents semi-automatically whether variables
  and method parameters hold references through which an object can possibly
  have its state changed.  It is, in fact, analogous to the use of the
  <TT>const</TT> keyword in C/C++; and this should set off alarm bells, because
  <TT>const</TT> is controversial and has well-known downsides.
</P>

<P>
  Perhaps most seriously, it can confuse novice programmers, because once you
  start using it, you have to use it consistently: you cannot cleanly call a
  non-<TT>const</TT>-aware library routine using a <TT>const</TT>-annotated
  handle.
</P>

<P>
  Furthermore, handles with guaranteed permission levels do not fit well with
  Melati's access model, in which objects (rows) may require different access
  capabilities or implement programmatic access policies, and yet we want links
  to other objects to be resolved transparently.  A programmer may have
  `guaranteed' read access to <TT>obj</TT>, but no promise can be made that
  <TT>obj.getFoo()</TT> is a readable handle to the linked <TT>foo</TT> until
  permissions have been checked.  So the compile-time guarantee that no access
  exceptions will be thrown is vitiated even in simple cases.
</P>

<P>
  For these reasons, and for simplicity (providing unbreakably read-only
  handles is quite complicated), we go with explicitly dynamic access checks.
  Note that checks still happen at a low level: posting guards on all the entry
  points to a Melati-based application is not strictly necessary for security.
</P>


<H4>
<!-- -------------------- -->
      The `current user'
<!-- -------------------- -->
</H4>

<P>
  The other main design decision for the access control API is how the identity
  of the user on whose behalf operations are being performed will be carried
  around.  The options considered were:
</P>

<UL>
  <LI> <I>Explicit.</I> A token representing the user must be passed
       into every API call for inspecting persistent data---which would make
       field accesses look like

       <BLOCKQUOTE><TT>
	 String issuer = line.getInvoice(user).getIssuer(user).getName(user);
       </TT></BLOCKQUOTE>

       Of course, provision could be made for the user info to be omitted if
       the programmer were willing to make the assumption that a field was
       ``world-readable''.  However, this mechanism still goes against the aim
       of near-transparent persistency.

  <LI> <I>Object-implicit.</I> Whenever an object is retrieved from
       the persistent store on behalf of a certain user, it contains her ID;
       requests to access fields via that object are implicitly made with her
       permissions, and linked objects by its accessors transitively carry her
       ID.  The disadvantages of this method are that it will cause a
       multiplicity of `object handles' to be created, each carrying a
       different user ID, and that the programmer's code may behave in
       confusing ways if she stores object references in her inter-session data
       structures.

  <LI> <I><A NAME=access-thread>Thread-implicit.</A></I> As soon as
       Melati takes control of the handling of each incoming HTTP transaction,
       it determines the identity of the user (if any) and records it against
       the thread started by webmacro's <TT>ResourceManager</TT> to service the
       event.  The persistent store can check the user's permissions whenever
       it needs to without the programmer ever having to mention them.
</UL>

<P>
  The thread-implicit technique seems to be the most convenient and transparent
  option for the programmer, given that the idea of a `current user' carrying
  implications for the capabilities of the running code is familiar from the
  process-ownership scheme implemented by all modern operating systems.
</P>

<P><FONT COLOR=green>
  <B>Implementation note.</B> The ideal way of implementing a thread-implicit
  `effective user ID' would be to subclass <TT>java.lang.Thread</TT> so as to
  be able to associate the ID with each thread directly as a field; but this
  option isn't available without making a minor change to
  <TT>org.webmacro.broker.ResourceManager</TT>.	 Instead, it is proposed that
  the thread-user association be maintained via a hash table or
  (possibly&nbsp;...) by manipulating the thread's name.
</FONT></P>


<H4><A NAME=overriding>
<!-- ---------------------------- -->
      Overriding access controls
<!-- ---------------------------- -->
</A></H4>

<P>
  For some purposes, it will be necessary to allow users to perform, in a
  controlled manner, operations for which they would not usually have the
  necessary access permissions.	 For example, the production of relatively
  insensitive summary reports may involve scanning a number of individually
  secret records.
</P>

<P>
  The example below sketches how anyone with read access to an invoice could be
  allowed to compute its total value even if they were not allowed to read its
  individual lines.
</P>

<BLOCKQUOTE><PRE>
public class Invoice extends InvoiceBase {

  ...

  public long totalValue() {

    // Fail if we don't have read access to `the invoice'.

    assertReadable(Implicit.accessToken());

    // If we do, force access to its constituent lines for this one operation.

    long value = 0L;

    Implicit.pushCapability(InvoiceLine.forceRead);

    try {
      for (Enumeration lines = getLines().elements();
	lines.hasMoreElements();)
	value += ((InvoiceLine)lines.nextElement()).getAmount()
      }
    }
    finally {
      // To avoid our having to remember to do this, the enhanced-capability
      // operation could be wrapped up in a Runnable.

      Implicit.popCapability();
    }

    return value;
  }

  ...
}

public class InvoiceLine extends InvoiceLineBase {

  ...

  // A capability used by Invoice.totalValue()
  // It's kept package-private in order to reduce the chance of leakage
  // leading to a more general access breach than intended.

  static final SettableCapability forceRead;

  ...

  public void assertReadable(AccessToken token) {
    if (!token.hasCapability(forceRead))
      super.assertReadable(token);
  }

  ...
}
</PRE></BLOCKQUOTE>


<H4>
<!-- --------- -->
      Summary
<!-- --------- -->
</H4>

<P>
  Under <A HREF=#access-thread>thread-implicit</A>, <A
  HREF=#access-dynamic>dynamic</A>, <A HREF=#cap-group>group-capability</A>
  access control, a persistent object behaves very like a file: you can legally
  attempt any defined operation on it, but if the user in whose name you are
  running is not a member of a group with an appropriate capability, an
  exception will be thrown following an (almost) indefeasible low-level check.
  <A HREF=#overriding>Bypassing</A> record permissions in order to support a
  particular operation is like setting an effective user ID for a particular
  utility program.
</P>


<H4>
<!-- ----------------------------------------- -->
      Protecting resources other than records
<!-- ----------------------------------------- -->
</H4>

<P>
  JAL's security model currently relies on restricting access to Webmacro
  handlers and templates.  There is no reason why Melati's capabilities model
  should not be used to support access control tests buried in the
  <TT>HandlerProvider</TT> and <TT>TemplateProvider</TT> supplied to Webmacro.
  But it's probably better just to have handlers examine the user's
  capabilities for themselves.  The following fragment shows how a handler for
  a generic record-editing service might do this:
</P>

<BLOCKQUOTE><PRE>
// Fetch the record specified in the form

String tableName = (String)context.getForm("table");
int recordNum = Integer.parseInt((String)context.getForm("id"));

Record record = database.table(tableName).record(recordNum);

try {
  // Fail if we can't read it

  record.assertReadable(Implicit.accessToken());

  // Fine, return the editing template

  ...
}
catch (AccessException e) {
  // Take appropriate action, e.g. returning a login template
  ...
}
</PRE></BLOCKQUOTE>

<P>
  NB in Melati, the worst that can happen if the checks are left too late is
  that the user gets an error message generated by the low-level persistent
  store after filling in and submitting a form.
</P>



<H3><A NAME=transactions>
<!-- ============== -->
      Transactions
<!-- ============== -->
</A></H3>

<P>
  One of the requirements for Melati is that it should support transactions
  (and that its data cache should remain consistent even when transactions are
  pending or get cancelled).  Integrating transactions with the API under which
  database records appear as transparently persistent objects poses the same
  problems as did the notion of the `current user': there has to be some way
  for the persistent store to know which transaction a data access (NB read as
  well as write!) is meant to belong to; but to require the programmer to pass
  a <TT>Connection</TT> handle into every call would spoil the illusion and
  degrade the simplicity of the interface.
</P>

<P>
  It is, however, anticipated that in nearly all cases, the pattern in which
  transactions are used will be very simple: for each incoming HTTP request,
  begin a new transaction; if an exception is thrown during processing, roll it
  back, but on successful completion, commit it.  <A NAME=xact-thread>So</A> it
  makes sense to adopt a model in which the `current transaction' is associated
  with the execution thread, just as it is <A HREF=#access-thread>proposed</A>
  that the `current user' should be.  The idea should be familiar from
  single-threaded SQL monitors like <TT>psql</TT>.  If the transaction is set
  up---along with the user ID---before any of the programmer's code runs, and a
  trap is put in place to cancel it if an exception condition occurs, then the
  right thing will generally happen automatically without the programmer having
  to think about it.
</P>

<P>
  Explicit checkpointing (committing) is also available, and if the programmer
  needs to perform some subtask in the context of a different transaction, she
  can do so with the following idiom:
</P>

<BLOCKQUOTE><PRE>
Session otherSession = ...;
...
Implicit.inSession(otherSession,
		   new Runnable {
		     public void run() {
		       // do the subtask
		     }
		   });
...
</PRE></BLOCKQUOTE>

<P>
  It goes without saying that behind the implicit transaction mechanism, Melati
  will support `connection pooling'.  <FONT COLOR=green><B>Implementation
  note:</B> perhaps Sun's new pooling utility will be suitable.</FONT>
</P>



<H3>
<!-- ============================ -->
      Retrieval and modification
<!-- ============================ -->
</H3>


<H4>
<!-- -------------------- -->
      Identified records
<!-- -------------------- -->
</H4>

<P>
  A record identified by its <A HREF=#primary>primary key</A> can be called up
  from the persistent store (cache or DBMS) by invoking a method on its table:

  <BLOCKQUOTE><TT>
    Invoice inv = database.invoiceTable().invoiceRecord(234);
  </TT></BLOCKQUOTE>
</P>

<P><FONT COLOR=green>
  <B>Implementation note.</B> The underlying <TT>SELECT</TT> used to retrieve
  identified or linked records by primary key is a cached
  <TT>PreparedStatement</TT>.
</FONT></P>


<H4>
<!-- ----------- -->
      Searching
<!-- ----------- -->
</H4>

<P>
  It's possible to ask for a <TT>SELECT</TT>ion of objects from a table via its
  <A HREF=javadoc/org.melati.Table.html#selection>selection</A> method.
  We may eventually want to support some minimally complicated way of
  constructing these queries without embedding literal SQL in the code; for
  instance:
</P>

<BLOCKQUOTE><PRE>
Enumeration them = invoiceTable.selection(
      Filter.like(Invoice.NUMBER, "123%"));
</PRE></BLOCKQUOTE>

<P>
  A sufficiently powerful `meta-language' of that kind should be able to
  support queries which automatically include the joins necessary to resolve
  references between objects.  But there may well be little need for that
  feature.
</P>

<P>
  The programmer can also run arbitrary <TT>SELECT</TT> queries on the
  database; the result will not be a stream of objects (so that <I>e.g.</I> any
  overriding of getter methods will be ignored) and will not be cached, but it
  ought to be possible to present it in a more friendly form than a
  <TT>ResultSet</TT>---perhaps an <TT>Enumeration</TT> of <TT>Field</TT>
  objects which can trivially be turned into appropriate markup in the <A
  HREF=#templating>template</A>.
</P>


<H4>
<!-- ------------------- -->
      Partial retrieval
<!-- ------------------- -->
</H4>

<P>
  For the moment it is not proposed that we support partial retrieval of
  records, <I>i.e.</I> specifying which fields should be uploaded from the
  database now (if they aren't cached) and leaving others to be loaded on
  demand.  This might save a little memory and IPC, and possibly disk accesses
  on the DBMS side if the records were very big, but it's probably not worth
  it.
</P>


<H4>
<!-- ---------- -->
      Updating
<!-- ---------- -->
</H4>

<P>
  Updates to records are supported transparently via the corresponding objects'
  setter methods.  By default, the invocation of any single setter method will
  result in an immediate <TT>UPDATE</TT> command being issued to the DBMS
  (although the change will not, of course, be visible outside the <A
  HREF=#xact-thread>current transaction</A>).  Since that behaviour is
  inefficient if one wants to change a number of fields at once, we may want to
  provide a way of batching updates into a single DBMS command.
</P>

<P>
  At the simplest, this is method pair <TT>record.cacheModifications()</TT>,
  which causes modifications to an object to stay in the data cache only, and
  <TT>.writeModifications()</TT>, which causes cached and future changes to be
  written down immediately as usual.  The problem is that you <I>have</I> to
  remember to turn write-down back on (and also the cache is slightly out of
  sync with the results you will get from <TT>SELECT</TT>s).
</P>

<P>
  So we wrap those in a <TT>record.apply</TT> method, which you use as
  follows:
</P>

<BLOCKQUOTE><PRE>
invoice.apply(new InvoiceUpdater {
  public void update(Invoice invoice) {
    invoice.setTaxDate(taxDate);
    invoice.setNotes(notes);
    ...
  }
});
</PRE></BLOCKQUOTE>

<P>
  But the most common situation in which a multi-field update is required is
  when reading values in from a form, and that is handled automatically (and
  atomically); the <TT>apply</TT> idiom will almost always always be
  unnecessary.
</P>


<H3><A NAME=cacheing>
<!-- ========== -->
      Cacheing
<!-- ========== -->
</A></H3>

<P>
  FIXME must support transactions and cacheing of whole subsets.  Transactions
  are handled by copying an object's underlying array of fields into a
  session-private cache when it is modified.  An easy, though possibly
  expensive, solution for subsets would be to copy the whole list of members
  into the session cache.
</P>



<H3>
<!-- ============================================= -->
      Representing field types and display styles
<!-- ============================================= -->
</H3>

<P>
  The fields attached to persistent objects are associated with rich typing and
  display preference information, which is used for creating displays and input
  boxes for their values in whatever <A HREF=#markup>markup language</A> the
  template is written in, and for generating javascript <A
  HREF=#validation>validation routines</A> for those inputs.
</P>


<H4>
<!-- -------------------------- -->
      The type/style hierarchy
<!-- -------------------------- -->
</H4>

<P>
  Clearly there is a necessary distinction between abstract type/style
  information and the markup-specific way in which it is used (the latter being
  encapsulated in an object representing the markup language).	Another
  possible cut is between types strictly so defined and display preferences,
  but it's not clear what would be gained by separating them into two, so it is
  proposed that the both should be encoded in the following set of classes
  (try the links to the javadoc API spec):
</P>

<UL>
<LI>
  <TT><A HREF=javadoc/org.melati.Type.html>Type</A></TT>&nbsp;&nbsp;
  Base of all types

  <UL>
  <LI>
    <TT><A HREF=javadoc/org.melati.AtomType.html>AtomType</A></TT> &nbsp;&nbsp;
    Base of all fundmental, non-reference types

    <UL>
    <LI>
      <TT><A HREF=javadoc/org.melati.NumberType.html>NumberType</A></TT>
      &nbsp;&nbsp;
      Base of all numeric types

      <UL>
      <LI>
	<TT><A HREF=javadoc/org.melati.IntegerType.html>IntegerType</A></TT>
	&nbsp;&nbsp;

	Plain old integers, the range being contingent on the
	underlying SQL type and on 

      <LI>
	<TT><A HREF=javadoc/org.melati.FixedType.html>FixedType</A></TT>
	&nbsp;&nbsp;
	Fixed point number, useful for currency fields

      <LI>
	<TT><A HREF=javadoc/org.melati.RealType.html>RealType</A></TT>
	&nbsp;&nbsp;
	By the way, we shouldn't really be using these for absolutely
	everything as we do now, but we may need them sometimes.
      </UL>

    <LI>
      <TT><A HREF=javadoc/org.melati.StringType.html>StringType</A></TT>
      &nbsp;&nbsp;
      Base of all character sequence types

      <UL>
      <LI>
	<TT><A HREF=javadoc/org.melati.TextType.html>TextType</A></TT>
	&nbsp;&nbsp;
	For multiline text area-type things
      </UL>
    </UL>

  <LI>
    <TT><A HREF=javadoc/org.melati.ReferenceType.html>ReferenceType</A></TT>
    &nbsp;&nbsp;
    For object references

  </UL>
</UL>


<H4><A NAME=valuesVsTypes>
<!-- ------------------------- -->
      Values <I>vs.</I> types
<!-- ------------------------- -->
</A></H4>

<P>
  Unlike in JAL, it is proposed that field values should <I>not</I>, in
  general, be stored and passed around with full type information attached, but
  instead as plain Java <TT>String</TT>s, <TT>int</TT>s and so on.  If the
  programmer needs to know more about the values than is evident from their
  Java types---which she mostly will not---she has to call a different method:
</P>

<BLOCKQUOTE><PRE>
String notes = invoice.getNotes();
TextType notesTypes = invoice.table().getNotesType();
</PRE></BLOCKQUOTE>

<P>
  The advantages claimed for this approach are a small gain in efficiency,
  since the values returned by getter methods can be slightly smaller and
  quicker to construct, and an improvement in transparency for the programmer:
  she can deal directly in familiar Java types.
</P>

<P>
  However, we will probably also want to provide convenience methods for
  packaging a value and a type/style together in a form in which they can be
  used to generate <A HREF=#markup>markup</A> concisely in templates.
</P>



<H3><A NAME=markup>
<!-- ================================== -->
      Defining markup languages/styles
<!-- ================================== -->
</A></H3>

<P>
  One of the aims for Melati is to tidy up JAL's facility for generating HTML
  for form elements corresponding to record fields, with a view to making it
  easier to understand, and capable of extension to work with WML and XML, and,
  perhaps, non-SGML-derived languages such as plain text (for emails) or
  something suitable for input to a PDF generator.
</P>

<P>
  <FONT COLOR=red>FIXME: this is in fact probably NOT how we will do it; we've
  realised that calling up mini subtemplates for controls is a much better
  idea!  Embedding HTML (or whatever) in the Java is just wrong, even if it's
  wrapped in some library.</FONT>
</P>


<H4>
<!-- ------------------------- -->
      Who does the rendering?
<!-- ------------------------- -->
</H4>

<P>
  The main issue to be resolved in the design of the new system is: how much
  commonality of structure do we assume between the target languages?
</P>

<UL>
  <LI> <I>Smart <TT>Type</TT>s.</I>
       We could assume that every markup language looks basically like HTML,
       and have each <TT>MarkupLanguage</TT> object provide an interface
       similar that offered by <A HREF=http://java.apache.org/ecs>ECS</A> to
       low-level elements such as <TT>&lt;INPUT&gt;</TT>s; the field
       <TT>Type</TT>s themselves would then be responsible for abstractly
       `rendering' any given value using the available operations.

  <LI> <I>Smart <TT>MarkupLanguage</TT>s.</I>
       Or, we could make each language responsible for knowing how to render
       every known kind of field.  This would potentially give us more
       flexibility in generating representations in languages which did not fit
       the HTML model very well; on the other hand, it would mean that all the
       <TT>MarkupLanguage</TT> implementations would have to be upgraded every
       time a new <TT>Type</TT>---perhaps <TT>Colour</TT> or
       <TT>ICQNumber</TT>---was added (at least if we wanted it to appear in a
       cute way).
</UL>

<P>
  It is proposed that the we should go with the first option, for the following
  reasons:
</P>

<UL>
  <LI> HTML was designed to be pretty generic with respect to the most familiar
       computer interfaces, so it makes a reasonable interface-rendering
       <I>API</I> even if the goal of expressing the logic of the document in
       an appearance-independent way falls down at the <I>application</I> level
       (which is why everyone uses HTML tags as appearance markup, why latex is
       so annoying, why we have decided to use templates, and why XML is going
       to be less cool than people think).

  <LI> We can probably use ECS directly (or at worst in a slightly hacked form)
       for the HTML <TT>MarkupLanguage</TT>!

  <LI> If we make the <TT>MarkupLanguage</TT> the primary entry point for the
       rendering routines, it still gets the chance to override the default
       ECS-style mechanism for specific types, and to offer nifty views of
       types it knows it can handle in a special way.
</UL>


<H4><A NAME=validation>
<!-- ------------ -->
      Validation
<!-- ------------ -->
</A></H4>

<P>
  JAL's mechanism for inserting Javascript fragments which perform client-side
  validation of form fields works by
</P>

<UL>
  <LI> including a Javascript header <TT>validation.js</TT> containing
    <UL>
      <LI> a variable holding a list of validation rules to be applied to the
	   page's fields
      <LI> Javascript routines for adding rules of various kinds to the list
      <LI> a <TT>validate</TT> routine for checking that the fields pass all
	   the tests
    </UL>

  <LI> inserting a script fragment alongside each field which adds an
       appropriate validation test to the list

  <LI> assigning an invocation of <TT>validate</TT> to the <TT>submit</TT>
       button's <TT>onClick</TT> method
</UL>

<P>
  This mechanism can be adopted unchanged, along with all the existing
  Javascript code, by Melati if it is made part of the HTML
  <TT>MarkupLanguage</TT>.  It is proposed that the script fragment simply be
  included along with the markup for each <TT>&lt;INPUT&gt;</TT> so that it
  does not have to be mentioned explicitly in the template; the inclusion of
  the trigger in the <TT>submit</TT> button should be made transparent in a
  similar way.
</P>




<H2><A NAME=templating>
<!-- ****************** -->
      Template authors
<!-- ****************** -->
</A></H2>

<P>
  <TT>MarkupLanguage</TT>s will provide template authors with easy-to-use
  facilities for inserting markup which renders field values (which need, for
  instance, to be escaped in a manner appropriate to the target language) and
  input controls.
</P>

<P>
  <FONT COLOR=red>FIXME: this is in fact probably NOT how we will do it; we've
  realised that calling up mini subtemplates for controls is a much better
  idea!  Embedding HTML (or whatever) in the Java is just wrong, even if it's
  wrapped in some library.</FONT>
</P>


<H4>
<!-- ------------------------- -->
      Displaying named fields
<!-- ------------------------- -->
</H4>

<P>
  The following example shows how part of a template for displaying an invoice
  might look.
</P>

<BLOCKQUOTE><PRE>
#set $ml = $jal2.HTMLMarkupLanguage

...

&lt;P&gt;Invoice number: $ml.display($invoice.NumberField)&lt;P&gt;

&lt;P&gt;Tax date: $ml.display($invoice.TaxDateField)&lt;/P&gt;

&lt;P&gt;Colour: $ml.displayColourSample($invoice.ColourField)&lt;/P&gt;

&lt;TABLE&gt;
#foreach $line in $invoice.Lines {
  &lt;TR&gt;
    &lt;TD&gt;$ml.display($line.Product.CodeField)&lt;/TD&gt;
    &lt;TD&gt;$ml.display($line.Product.DescriptionField)&lt;/TD&gt;
    &lt;TD&gt;$ml.display($line.AmountField)&lt;/TD&gt;
  &lt;/TR&gt;
}
&lt;/TABLE&gt;
</PRE></BLOCKQUOTE>

<P>
  At the top of the template is a directive for obtaining an HTML renderer
  <TT>$ml</TT> which is then used explicitly to display each field.  <FONT
  COLOR=red>FIXME: It might be possible to make the markup language a (thread-)
  global setting like the <A HREF=#access-thread>current user</A> and <A
  HREF=#xact-thread>current transaction</A>---need to check what is possible in
  webmacro's syntax.</FONT> The labels <TT>NumberField</TT>,
  <TT>TaxDateField</TT>, ... are used in place of <TT>Number</TT>,
  <TT>TaxDate</TT>, ... to retrieve both value and type/style information
  simultaneously (see <A HREF=#valuesVsTypes>above</A>).
</P>

<P>
  Note the use of the <TT>displayColourSample</TT> method to force a field to
  be displayed in a particular form: it's entirely open to the template writer
  to use language-specific special rendering techniques, because, of course,
  she knows what language she is writing for.
</P>

<P>
  Pulling the items out of the invoice is trivial: the template writer can
  simply invoke its <TT>getLines</TT> to obtain an enumerable container with
  the appropriate objects in it.
</P>


<H4>
<!-- ----------------------------------- -->
      Generating forms for named fields
<!-- ----------------------------------- -->
</H4>

<P>
  Forms for named fields are handled in a similar way (<FONT COLOR=red>FIXME
  this is impressionistic at the moment</FONT>); <A HREF=#validation>recall</A>
  that validation snippets are included along with the markup for each input:
</P>

<BLOCKQUOTE><PRE>
#set $ml = $jal2.HTMLMarkupLanguage

$ml.BodyInclusions  &lt;!-- get the javascript header in --&gt;

...

&lt;P&gt;Invoice number: $ml.input($invoice.NumberField)&lt;P&gt;

&lt;P&gt;Tax date: $ml.input($invoice.TaxDateField)&lt;/P&gt;

&lt;INPUT TYPE=submit value=Update name=Update
 $ml.SubmitButtonAttributes&gt;
</PRE></BLOCKQUOTE>


<H4>
<!-- ---------------- -->
      Generic fields
<!-- ---------------- -->
</H4>

<P>
  Templates for applications like the admin system are written in a similar
  style their JAL equivalents:
</P>

<BLOCKQUOTE><PRE>
#set $ml = $jal2.HTMLMarkupLanguage

$ml.BodyInclusions  &lt;!-- get the javascript header in --&gt;

...

&lt;TABLE&gt;
# foreach $field in $object {
    &lt;TR&gt;
      &lt;TD&gt;$ml.label($field)&lt;/TD&gt;
      &lt;TD&gt;$ml.input($field)&lt;/TD&gt;
    &lt;/TR&gt;
  }
&lt;/TABLE&gt;

&lt;INPUT TYPE=submit value=Update name=Update
 $ml.SubmitButtonAttributes&gt;
</PRE></BLOCKQUOTE>




<H2>
<!-- ************ -->
      Installers
<!-- ************ -->
</H2>


<H4>
<!-- ---------------------------- -->
      Operations to be performed
<!-- ---------------------------- -->
</H4>

<P>
  There is a really hair-raising list of things that have to be done before a
  JAL application can be delivered.  The following is a summary taken from the
  <A HREF=http://paneris.org/cgi-bin/cvsweb.cgi/~checkout~org/paneris/jal/qa/Installation.html>JAL
  Installation Guide</A>:
</P>

<UL>
  <LI> Install
    <UL>
      <LI> <B>Java.</B> Relatively standard, but RedHat, the most popular Linux
	   distribution in the English-speaking world, doesn't even ship it,
	   let alone install it by default.  <FONT COLOR=red>Or do they
	   now?</FONT>

      <LI> <B>Apache.</B> Standard; installed by default on all Linux servers.

      <LI> <B>JSDK</B> servlet development kit.	 Standard; only needs to be put
	   in the Java classpath.

      <LI> <B>JServ</B> servlet runner.	 Relatively standard, but there are
	   hoops to jump through to get RedHat 6's Apache installation to
	   install it. <FONT COLOR=red>Is it still like this?</FONT>

      <LI> <B>Webmacro.</B> Nonstandard, but only needs to be put in the
	   Java classpath.

      <LI> <B>Postgres.</B> Standard and shipped with RedHat (though it still
	   needs nontrivial initialisation before you can begin to configure
	   databases, and you have to put its Java drivers in the classpath
	   yourself).

      <LI> <B>OROMatcher.</B>  Nonstandard, but only needs to be put in the
	   Java classpath.

      <LI> <B>JAL</B> itself with Paneris libraries and the actual application.
	   Needs to be put in the Java classpath and Apache's static content
	   area.
    </UL>

  <LI> Configure all the above.	 This involves editing half a dozen nontrivial
       configuration files and knowing what a servlet repository is.

  <LI> Ensure that Apache and Postgres get started at boot time (the RedHat
       RPMs do this for you).

  <LI> Set up the databases for the application.
</UL>

<P>
  Melati can carry out the very last step automatically by running
  <TT>CREATE</TT> <TT>TABLE</TT> and <TT>CREATE</TT> <TT>INDEX</TT> commands
  determined from the <A HREF=#data-def>data structure
  definition</A>---assuming that Postgres thinks the installer has
  database-creation rights (current JAL applications provide a
  <TT>psql</TT>-based script for this purpose).	 However, the other steps would
  be exceedingly difficult to automate in a way which would dovetail with an
  existing setup on a customer's machine: the only viable means of coexisting
  with their settings would be to use the API of a configuration tool like
  <TT>linuxconf</TT> (but even <TT>linuxconf</TT> doesn't know about
  <I>e.g.</I> <TT>mod-jserv</TT>).  That leaves two possible solutions, which
  we could offer as alternatives:
</P>

<UL>
  <LI> The customer installs and configures everything from scratch.  In
       practice this will mean them paying an experienced Paneris insider to do
       it.  I think the sheer variety of different packages involved, even more
       than the complexity of the process, will be a significant barrier to the
       adoption of Melati by the wider open source community.  For a more
       optimistic view, here are TimJ's comments:

       <BLOCKQUOTE><I>
	 umm, noone is pretending it is straightforward, but i think it is
	 within the capablities of all webmacro users.  NB ISPs such as ednet
	 (and others that host servlets) provide an environment with Linux,
	 apache, Postgres, Java, JSDK, leaving the user just to messabout with
	 classpaths.
       </I></BLOCKQUOTE>

  <LI> The customer drops a massive tarball, containing everything from
       Apache to Melati pre-configured to work together, on top of a more or
       less blank installation of a particular OS (<I>e.g.</I> the current
       RedHat).  Such a drastic operation will not appeal to developers, but
       might be quite convenient for customers looking to put up a dedicated
       server for a Paneris site.  We will mention this as an option and do it
       if there is demand.
</UL>


<H4>
<!-- ----------------- -->
      Delivery medium
<!-- ----------------- -->
</H4>

<P>
  Most of the installation will have to be carried out from a command prompt on
  Linux; the best interface for NT/W2K will be decided when the port is made.
  However the creation of a Melati application database could be carried out by
  pressing a button on the web admin interface.
</P>




<H2>
<!-- **************** -->
      Administrators
<!-- **************** -->
</H2>



<H3><A NAME=adminsystem>
<!-- ====================== -->
      Generic admin system
<!-- ====================== -->
</A></H3>

<P>
  The generic admin system looks essentially identical to JAL's existing
  screens.  New database fields and even tables can be added, and will be
  available for use in templates and generic report/data entry screens: the <A
  HREF=#data-def>data structure definition</A> is not exclusive.
</P>

<P>
  Field display preferences set in the data structure definition---canonically,
  the default height of a <TT>TEXTAREA</TT>---can be adjusted freely by the
  administrator; the system will never `change them back', because the system
  only ever <I>adds</I> fields in the DSD which are missing from the running
  database.  <FONT COLOR=red>FIXME: TimJ points out that this could be
  confusing: ``I changed my DSD and regenerated, but my text area is still the
  same size''.  It is confusing, and we need a warning message, but the only
  alternative is to remove preference information to a separate file, and that
  would detract from the appealing conciseness of the notation.</FONT>
</P>

<P>
  The administrator is not allowed to change the basic type of any field,
  <I>e.g.</I> from <TT>INT</TT> to <TT>FLOAT</TT> or from <TT>VARCHAR(10)</TT>
  to <TT>VARCHAR(11)</TT> (Postgres doesn't support this).  She can delete a
  field (and add it again in a different form), or rename it, provided that it
  was not declared in the data structure definition; whenever such a change is
  made (which is assumed to be seldom), the data cache is cleared of records
  from the table in question, because otherwise the persistent store would have
  to cope with multiple versions of a table's shape.
</P>


<H4>
<!-- ----------------- -->
      Delivery medium
<!-- ----------------- -->
</H4>

<P>
  Administrators access Melati's services over a web interface.  <FONT
  COLOR=red>Can we use secure transport for sensitive purposes?</FONT>
</P>




<H2>
<!-- ******* -->
      Users
<!-- ******* -->
</H2>



<H3>
<!-- ============================= -->
      Self-management of identity
<!-- ============================= -->
</H3>

<P>
  Login and password management look essentially identical to JAL's existing
  screens.
</P>


<H4>
<!-- ----------------- -->
      Delivery medium
<!-- ----------------- -->
</H4>

<P>
  Users access Melati's services over a web interface.  <FONT COLOR=red>Can we
  use secure transport for sensitive purposes?</FONT>
</P>




<H2>
<!-- **************************** -->
      Traces of typical sessions
<!-- **************************** -->
</H2>

<P>
  The ways in which users can achieve the goals expected of them by
  navigating through the system are:
</P>

<P>
  <FONT COLOR=red>Complete, working examples to follow here eventually.</FONT>
</P>




<H2>
<!-- *************** -->
      Externalities
<!-- *************** -->
</H2>

<P>
  The external circumstances which are essential to the correct and
  reliable operation of the system are:
</P>

<UL>
  <LI> backups, which are outside the scope of Melati
  <LI> <FONT COLOR=red>FIXME: anything else?</FONT>
</UL>




<H2>
<!-- *************** -->
      Risk analysis
<!-- *************** -->
</H2>

<P>
  The obvious ways in which this specification might turn out to be
  poor are:
</P>

<UL>
  <LI> It might turn out that we need more flexiblity in the eventual
       <TT>CREATE</TT> <TT>TABLE</TT> statements than we get from the <A
       HREF=#data-def>data structure definition language</A>.

  <LI> The <A HREF=#xact-thread>implicit transaction model</A> might be
       inconvenient if a programmer wanted to use several transactions in
       parallel in some complex application.
</UL>

<P>
  The obvious ways in which the implementation of this specification
  might fail are:
</P>

<UL>
  <LI> It may take a while for Melati to match the full range of features
       offered by JAL, and until it does, there's a risk that Paneris
       developers will go on using the latter rather than extending Melati
       appropriately.
</UL>


<HR>




<H2>
<!-- ********************* -->
      About this document
<!-- ********************* -->
</H2>

<H3>
<!-- ========= -->
      Authors
<!-- ========= -->
</H3>

<P>
  <A HREF=mailto:williamc@paneris.org>William Chesters
  &lt;williamc@paneris.org&gt;</A>
</P>

<P>
  Most recent CVS $Author$ @paneris.org
</P>

<H3>
<!-- ========= -->
      Quality
<!-- ========= -->
</H3>

<P>
  The current quality level of this document is: <B>Alpha</B>. There are
  decisions yet to be made, sections to be filled out and some additions to
  come (including more examples).  Some of the content would fit better in the
  Requirements Specification.
</P>

<H3>
<!-- ======================== -->
      Readership and purpose
<!-- ======================== -->
</H3>

<P>
  <UL>
    <LI> The <B>customer</B> should feel confident that they will
	 get want they want, and that they know who
	 will be able to use their system, how it will feel,
	 who they need to train, how they will have to support it.
    <LI> The <B>project leader</B> should feel happy about taking
	 responsibility for leading the internal design of the
	 system.
    <LI> The <B>developers</B> should feel informed about the
	 way the system as a whole fits together.
    <LI> <B>Future maintainers</B> should be able to understand the
	 way the system as a whole fits together.
  </UL>

  This document is also intended to give the wider <B>open source
  community</B> an insight into the motivation behind Melati, so
  that they can give us feedback pre-release and understand the
  finished product.
</P>

<H3>
<!-- ========= -->
      History
<!-- ========= -->
</H3>

<P>
  The important points in the life of this document are listed
  below.
</P>

<TABLE>
  <TR><TH>Date</TH><TH>Event</TH></TR>
  <TR>
    <TD>(not yet)</TD>
    <TD>Certified at release quality level by ...</TD>
  </TR>
</TABLE>

<P>
  The CVS log for this document is:
  <BR>
  <BR>$Log$
  <BR>Revision 1.6  2000/02/25 20:20:36  williamc
  <BR>Snapshot of 25 Feb 2000
  <BR>
  <BR>Revision 1.2  2000/02/04 18:28:34  williamc
  <BR>Add QA stub; explain DSD-admin interactino a little better
  <BR>
  <BR>
</P>


</BODY>
</HTML>
